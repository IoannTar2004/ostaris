# Операционная система Ostaris
Представляет собой очень упрощённую операционную систему на простой архитектуре, чем то напоминающую RISC-V.

## Регистры общего назначения
Все 64-битные.

| Регистр  | Описание                                             |
|----------|------------------------------------------------------|
| rtv      | return value. Возвращаемое значение                  |
| ar0-ar4  | argument 0-4. Регистры для аргументов функции        |
| ip       | instruction pointer. Указатель на текущую инструкцию |
| sp       | stack pointer. Указатель на вершину стека            |
| bf0-bf23 | buffer registers. Дополнительные регистры            |

## Система команд (ISA)
Все инструкции захардкожены, то есть все инструкции изменяют состояние процессора за одну строчку (или почти за одну).
Инструкции 32-битные.

### Арифметика регистров
| Инструкция         | Мнемоника                     | Код инструкции |
|--------------------|-------------------------------|----------------|
| AND r1, r2, r3     | r1 & r2 -> r3                 | 0x01           |
| OR r1, r2, r3      | r1 \| r2 -> r3                | 0x02           |
| NEG r1, r2         | ~r1 -> r2                     | 0x03           |
| XOR r1, r2, r3     | r1 ^ r2 -> r3                 | 0x04           |
| ADD r1, r2, r3     | r1 + r2 -> r3                 | 0x05           |
| SUB r1, r2, r3     | r1 - r2 -> r3                 | 0x06           |
| MUL r1, r2, r3     | r1 * r2 -> r3                 | 0x07           |
| DIV r1, r2, r3, r4 | r1 // r2 -> r3, r1 % r2 -> r4 | 0x08           |
| CMP r1, r2         | r1 - r2 -> FLAGS(fl)          | 0x09           |
| MV r1, r2          | r1 -> r2                      | 0x0A           |

**Формат инструкции**

| Код | r3    |
|-----|-------|
| rtv | 5 бит |

### Арифметика регистра и константы. n - число. Суффикс C в конце инструкции означает константа (Const).
| Инструкция         | Мнемоника                   | Код инструкции |
|--------------------|-----------------------------|----------------|
| ANDС r1, n, r3     | r1 & n -> r3                | 0x0B           |
| ORC r1, n, r3      | r1 \| n -> r3               | 0x0C           |
| NEGC n, r2         | ~n -> r2                    | 0x0D           |
| XORC r1, n, r3     | r1 ^ n -> r3                | 0x0E           |
| ADDC r1, n, r3     | r1 + n -> r3                | 0x0F           |
| SUBС r1, n, r3     | r1 - n -> r3                | 0x10           |
| MULC r1, n, r3     | r1 * n -> r3                | 0x11           |
| DIVC r1, n, r3, r4 | r1 // n -> r3, r1 % n -> r4 | 0x12           |
| CMPC r1, n         | r1 - n -> FLAGS(**fl**)     | 0x13           |
| MVC r1, n          | n -> r1                     | 0x14           |

### Память
- ptr - адрес в памяти

| Инструкция      | Мнемоника                            | Код инструкции |
|-----------------|--------------------------------------|----------------|
| LD r1, \[ptr\]  | memory(ptr) -> r1                    | 0x15           |
| MEM r1, \[ptr\] | r1 -> memory(ptr)                    | 0x16           |
| LDC r1, n       | n -> L1                              | 0x17           |
| MEMС n, \[ptr\] | n -> memory(ptr)                     | 0x18           |
| PUSH r1         | **sp** - 1 -> **sp**; r1 -> **\*sp** | 0x19           |
| POP r1          | **\*sp** -> r1; **sp** + 1 -> **sp** | 0x1A           |

### Переходы.
- Z (Zero) - устанавливается, если r1 равен r2 в инструкции CMP/CMPC.
- N (Negative) устанавливается, если r1 меньше r2 в инструкции CMP/CMPC.

| Инструкция   | Мнемоника                                                   | Код инструкции |
|--------------|-------------------------------------------------------------|----------------|
| JMP \[ptr\]  | ptr -> **ip**                                               | 0x1B           |
| JE \[ptr\]   | if Z == 1: ptr -> **ip**                                    | 0x1C           |
| JNE \[ptr\]  | if Z == 0: ptr -> **ip**                                    | 0x1D           |
| JL \[ptr\]   | if N == 1 and Z == 0: ptr -> **ip**                         | 0x1E           |
| JG \[ptr\]   | if N == 0 and Z == 0: ptr -> **ip**                         | 0x1F           |
| JLE \[ptr\]  | if N == 1 or Z == 1: ptr -> **ip**                          | 0x20           |
| JGE \[ptr\]  | if N == 0 or Z == 1: ptr -> **ip**                          | 0x21           |
| CALL \[ptr\] | **sp** - 1 -> **sp**; **ip** + 1 -> **\*sp**; ptr -> **ip** | 0x22           |
| RET          | **\*sp** -> **ip**; **sp** + 1 -> **sp**                    | 0x23           |

### Прерывания
Пока реализованы не будут
